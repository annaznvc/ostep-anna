1. First, open two separate terminal connections to the same machine,
so that you can easily run something in one window and the other.
Now, in one window, run vmstat 1, which shows statistics about
machine usage every second. Read the man page, the associated
README, and any other information you need so that you can understand its output. Leave this window running vmstat for the
rest of the exercises below.
Now, we will run the program mem.c but with very little memory
usage. This can be accomplished by typing ./mem 1 (which uses
only 1 MB of memory). How do the CPU usage statistics change
when running mem? Do the numbers in the user time column
make sense? How does this change when running more than one
instance of mem at once?

    Je mehr Prozesse von mem laufen, desto höher ist die anzahl im user column
    mem steigt
    Wait sinkt (mem macht kein io, cpu wartet also nicht auf ein io gerät)


2.Let’s now start looking at some of the memory statistics while running mem. We’ll focus on two columns: swpd (the amount of virtual memory used) and free (the amount of idle memory). Run ./mem 1024 (which allocates 1024 MB) and watch how these values change. Then kill the running program (by typing control-c) and watch again how the values change. What do you notice about the values? In particular, how does the free column change when the program exits? Does the amount of free memory increase by the expected amount when mem exits?

    swpd tbh keine änderung
    free space nimmt ab, steigt aber wieder beim terminieren

3.We’ll next look at the swap columns (si and so), which indicate how much swapping is taking place to and from the disk. Of course, to activate these, you’ll need to run mem with large amounts of memory. First, examine how much free memory is on your Linux system (for example, by typing cat /proc/meminfo type man proc for details on the /proc file system and the types of information you can find there). One of the first entries in /proc/meminfo is the total amount of memory in your system. Let’s assume it’s something like 8 GB of memory; if so, start by running mem 4000 (about 4 GB) and watching the swap in/out columns. Do they ever give non-zero values? Then, try with 5000, 6000, etc. What happens to these values as the program enters the second loop (and beyond), as compared to the first loop? How much data (total) are swapped in and out during the second, third, and subsequent loops? (do the numbers make sense?)

    Im ersten Loop ist si = 0
        -> pages wurden frisch allokiert
        -> Inhalt zuvor noch nie ausgelager
        ->Es gibt nichts, was zurückgeholt werden muss

    In darauffolngenden loops steigen si und so
        -so geht oft schlagartig von 0 -> mehrere tausend -> 0
        -si bleibt meist stabil von 0-100 mit paar Ausreiser im tausender bereich

Swap Out passiert in großen Sprüngen, weil linux mit LW und HW arbeitet, man swappt also am stück mehrere mb oder gb aus auf ein mal

SI hängt hingegen davon ab, ob Prozesse zufällig eine ausgelagerte Page brauchen. das passiert viel häufiger und granularer, es werden ständig vereinzelte pages wieder reingeholt

    


4. Do the same experiments as above, but now watch the other statistics (such as CPU utilization, and block I/O statistics). How do they change when mem is running?




    Mit 14 GB:
    bi (block in) sehr hoch beim swap in
    bo (block out) hoch bei swap out, aber mit mehr nullen dazwischen
    wa ????
    st ???
    in nimmt stark zu
    cs nimmt stark zu weil prozesse ständig auf io warten
    sy nimmt zu kernel arbeitet viel, üage handling, page table work
    US nimmt zu 
    id nimmt etwas ab idle, cpu ist häufiger beschäftgit


5. Now let’s examine performance. Pick an input for mem that comfortably fits in memory (say 4000 if the amount of memory on the system is 8 GB). How long does loop 0 take (and subsequent loops 1, 2, etc.)? Now pick a size comfortably beyond the size of memory (say 12000 again assuming 8 GB of memory). How long do the loops take here? How do the bandwidth numbers compare? How different is performance when constantly swapping versus fitting everything comfortably in memory? Can you make a graph, with the size of memory used by mem on the x-axis, and the bandwidth of accessing said memory on the y-axis? Finally, how does the performance of the first loop compare to that of subsequent loops, for both the case where everything fits in memory and where it doesn’t?


